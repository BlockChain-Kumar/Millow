import { network } from "hardhat";
import * as fs from "fs";
import * as path from "path";
// Import the types generated by the plugin
import { RealEstate, Escrow } from "../types/ethers-contracts/index.js";
// import { RealEstate, Escrow } from "@nomicfoundation/hardhat-typechain"


async function main() {
    // hardhat v3 : get 'ether' from the network connection
    const connection = await network.connect();
    const ethers = connection.ethers;

    const [deployer, seller, inspector, lender] = await ethers.getSigners();
    console.log("Deploying Contracts with the account : ", deployer.address);

    // 1. deploy Real Estate NFT
    const RealEstateFactory = await ethers.getContractFactory("RealEstate");
    // casting : using the imported type
    const realEstate = (await RealEstateFactory.deploy()) as unknown as RealEstate;
    // alternatively const realEstate = await ethers.deployContract("RealEstate");
    await realEstate.waitForDeployment();

    const realEstateAddress = await realEstate.getAddress();
    console.log(`RealEstate Contract deployed to : ${realEstateAddress}`);
    console.log(`Minting 3 properties...`);

    // Mint 3 NFTs for testing
    // Note: In a real app, these IPFS links would be real metadata
    // Mint 3 NFTs for testing
    for (let i = 1; i <= 3; i++) {
        // CASTING ADDED HERE:
        await (await (realEstate.connect(seller) as unknown as RealEstate).mint(`https://ipfs.io/ipfs/QmToyMtEyvkGFnaqo5gqqHeauCancun${i}`)).wait();
    }



    // 2. Deplou Escrow
    const EscrowFactory = await ethers.getContractFactory("Escrow");

    // Casting : using the imported type
    const escrow = (await EscrowFactory.deploy(
        realEstateAddress,
        seller.address,
        inspector.address,
        lender.address
    )) as unknown as Escrow;
    await escrow.waitForDeployment();


    const escrowAddress = await escrow.getAddress();
    console.log(`Escrow deployed to: ${escrowAddress}`);
    // --- 3. Approve Escrow ---
    console.log("Approving Escrow...");
    // Explicit cast on connect() to ensure setApprovalForAll is recognized
    await (await (realEstate.connect(seller) as unknown as RealEstate).setApprovalForAll(escrowAddress, true)).wait();


    // --- 4. Save to Frontend ---
    await updateFrontend(realEstateAddress, realEstate, "RealEstate");
    await updateFrontend(escrowAddress, escrow, "Escrow");
}
async function updateFrontend(address: string, contract: any, contractName: string) {
    // PATH : backend/scripts -> backend -> root -> frontend -> constants

    // CHANGE: Use process.cwd() instead of __dirname
    // process.cwd() = .../backend
    // ..            = .../ (Root)
    // frontend      = .../frontend
    const constantsDir = path.join(process.cwd(), "..", "frontend", "constants");    // may give the path directly 
    //Sanity check
    if (!fs.existsSync(constantsDir)) {
        console.error(`Error : could not find folder : ${constantsDir}`);
        return;
    }

    // A. save Address
    fs.writeFileSync(
        path.join(constantsDir, `${contractName}_Address.json`),
        JSON.stringify({ address: address }, null, 2)
    );

    // B. save ABI
    // In v3, we check if the interface exists before formatting 
    if (contract.interface) {
        fs.writeFileSync(
            path.join(constantsDir, `${contractName}_ABI.json`),
            contract.interface.formatJson()
        );
    } else {
        console.error(`Error: Could Not Extract ABI from contract object`);
    }

    console.log(` Config updated for ${contractName}`);
}
main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});